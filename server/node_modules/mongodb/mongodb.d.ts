import type { DeserializeOptions } from 'bson';
import type { ObjectIdLike } from 'bson';
import type { SerializeOptions } from 'bson';
import { Binary } from 'bson';
import { BSON } from 'bson';
import { BSONRegExp } from 'bson';
import { BSONSymbol } from 'bson';
import { BSONType } from 'bson';
import { Code } from 'bson';
import { DBRef } from 'bson';
import { Decimal128 } from 'bson';
import { deserialize } from 'bson';
import { Document } from 'bson';
import { Double } from 'bson';
import { Int32 } from 'bson';
import { Long } from 'bson';
import { MaxKey } from 'bson';
import { MinKey } from 'bson';
import { ObjectId } from 'bson';
import { serialize } from 'bson';
import { Timestamp } from 'bson';
import { UUID } from 'bson';
import type { SrvRecord } from 'dns';
import { EventEmitter } from 'events';
import type { Socket } from 'net';
import type { TcpNetConnectOpts } from 'net';
import { Readable } from 'stream';
import { Writable } from 'stream';
import type { ConnectionOptions as ConnectionOptions_2 } from 'tls';
import type { TLSSocket } from 'tls';
import type { TLSSocketOptions } from 'tls';

/** @public */
export declare type Abortable = {
    /**
     * @experimental
     * When provided, the corresponding `AbortController` can be used to abort an asynchronous action.
     *
     * The `signal.reason` value is used as the error thrown.
     *
     * @remarks
     * **NOTE:** If an abort signal aborts an operation while the driver is writing to the underlying
     * socket or reading the response from the server, the socket will be closed.
     * If signals are aborted at a high rate during socket read/writes this can lead to a high rate of connection reestablishment.
     *
     * We plan to mitigate this in a future release, please follow NODE-6062 (`timeoutMS` expiration suffers the same limitation).
     *
     * AbortSignals are likely a best fit for human interactive interruption (ex. ctrl-C) where the frequency
     * of cancellation is reasonably low. If a signal is programmatically aborted for 100s of operations you can empty
     * the driver's connection pool.
     *
     * @example
     * ```js
     * const controller = new AbortController();
     * const { signal } = controller;
     * process.on('SIGINT', () => controller.abort(new Error('^C pressed')));
     *
     * try {
     *   const res = await fetch('...', { signal });
     *   await collection.findOne(await res.json(), { signal });
     * catch (error) {
     *   if (error === signal.reason) {
     *     // signal abort error handling
     *   }
     * }
     * ```
     */
    signal?: AbortSignal | undefined;
};

/** @public */
export declare abstract class AbstractCursor<TSchema = any, CursorEvents extends AbstractCursorEvents = AbstractCursorEvents> extends TypedEventEmitter<CursorEvents> implements AsyncDisposable_2 {
    /* Excluded from this release type: cursorId */
    /* Excluded from this release type: cursorSession */
    /* Excluded from this release type: selectedServer */
    /* Excluded from this release type: cursorNamespace */
    /* Excluded from this release type: documents */
    /* Excluded from this release type: cursorClient */
    /* Excluded from this release type: transform */
    /* Excluded from this release type: initialized */
    /* Excluded from this release type: isClosed